{"version":3,"file":"hyperleaflet.umd.js","sources":["../src/hyperchange.js","../src/geometry.js","../src/hyperleaflet.js","../src/index.js"],"sourcesContent":["/**\n * HyperChange — MutationObserver diffing for hypermedia apps.\n *\n * Watches a DOM subtree and emits semantic add/remove/change events\n * by diffing nodes against a unique key attribute. Designed for use\n * with htmx, Turbo, LiveView, or any server-rendered HTML workflow\n * that swaps DOM content and needs to sync with imperative JS libraries.\n *\n * Internal module — not published as a separate package.\n */\n\nconst VALID_EVENTS = ['add', 'remove', 'change'];\n\nexport class HyperChange {\n  /**\n   * @param {HTMLElement} root — container element to observe\n   * @param {object} options\n   * @param {string} options.key — attribute name used as unique identifier (e.g. 'data-id')\n   * @param {string[]} [options.watch=[]] — attributes to track for change detection\n   * @param {boolean} [options.batch=false] — batch mutations per animation frame\n   */\n  constructor(root, options) {\n    if (!root || !(root instanceof HTMLElement)) {\n      throw new Error('HyperChange: root must be an HTMLElement');\n    }\n    if (!options || !options.key) {\n      throw new Error('HyperChange: options.key is required');\n    }\n\n    this._root = root;\n    this._key = options.key;\n    this._watch = options.watch || [];\n    this._batch = options.batch || false;\n    this._listeners = { add: [], remove: [], change: [] };\n    this._frameId = null;\n    this._pendingMutations = [];\n    this._disconnected = false;\n\n    const hasWatch = this._watch.length > 0;\n\n    this._observer = new MutationObserver((mutations) => {\n      if (this._batch) {\n        this._pendingMutations.push(...mutations);\n        if (this._frameId === null) {\n          this._frameId = requestAnimationFrame(() => {\n            this._frameId = null;\n            const batch = this._pendingMutations.splice(0);\n            this._process(batch);\n          });\n        }\n      } else {\n        this._process(mutations);\n      }\n    });\n\n    this._observer.observe(root, {\n      childList: true,\n      subtree: true,\n      attributes: hasWatch,\n      attributeFilter: hasWatch ? this._watch : undefined,\n      attributeOldValue: hasWatch,\n    });\n  }\n\n  /**\n   * Subscribe to an event.\n   * @param {'add'|'remove'|'change'} event\n   * @param {function} handler\n   * @returns {function} unsubscribe function\n   */\n  on(event, handler) {\n    if (this._disconnected) {\n      throw new Error('HyperChange: cannot subscribe after disconnect');\n    }\n    if (!VALID_EVENTS.includes(event)) {\n      throw new Error(\n        'HyperChange: invalid event \"' + event + '\". Must be one of: ' + VALID_EVENTS.join(', ')\n      );\n    }\n    this._listeners[event].push(handler);\n    return () => {\n      this._listeners[event] = this._listeners[event].filter((h) => h !== handler);\n    };\n  }\n\n  /**\n   * Remove a specific handler.\n   * @param {'add'|'remove'|'change'} event\n   * @param {function} handler\n   */\n  off(event, handler) {\n    if (this._listeners[event]) {\n      this._listeners[event] = this._listeners[event].filter((h) => h !== handler);\n    }\n  }\n\n  /**\n   * Fire 'add' events for all existing keyed children.\n   * Useful for initial state — call after setting up handlers.\n   */\n  scan() {\n    const nodes = this._collectKeyedNodes(this._root);\n    if (nodes.length > 0) {\n      this._emit('add', nodes.map((node) => ({\n        node,\n        key: node.getAttribute(this._key),\n      })));\n    }\n  }\n\n  /**\n   * Stop observing. Clears all listeners. Instance is unusable after this.\n   */\n  disconnect() {\n    this._disconnected = true;\n    this._observer.disconnect();\n    if (this._frameId !== null) {\n      cancelAnimationFrame(this._frameId);\n      this._frameId = null;\n    }\n    this._pendingMutations = [];\n    this._listeners = { add: [], remove: [], change: [] };\n  }\n\n  // --- Private ---\n\n  /**\n   * Iteratively find all elements with the key attribute under a root.\n   * Uses a stack instead of recursion to avoid stack overflow on deep trees.\n   */\n  _collectKeyedNodes(root) {\n    const result = [];\n    const stack = [];\n\n    // Push root's children onto stack (reverse order so first child is processed first)\n    for (let i = root.childNodes.length - 1; i >= 0; i--) {\n      stack.push(root.childNodes[i]);\n    }\n\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (node.nodeType !== 1) continue;\n      if (node.hasAttribute(this._key)) result.push(node);\n      for (let i = node.childNodes.length - 1; i >= 0; i--) {\n        stack.push(node.childNodes[i]);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Collect keyed nodes from a NodeList (used for MutationRecord addedNodes/removedNodes).\n   */\n  _collectKeyedFromNodeList(nodeList) {\n    const result = [];\n    for (const node of nodeList) {\n      if (node.nodeType !== 1) continue;\n      if (node.hasAttribute(this._key)) result.push(node);\n      // Also check descendants — a parent element may contain keyed children\n      const stack = [];\n      for (let i = node.childNodes.length - 1; i >= 0; i--) {\n        stack.push(node.childNodes[i]);\n      }\n      while (stack.length > 0) {\n        const child = stack.pop();\n        if (child.nodeType !== 1) continue;\n        if (child.hasAttribute(this._key)) result.push(child);\n        for (let i = child.childNodes.length - 1; i >= 0; i--) {\n          stack.push(child.childNodes[i]);\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Process a batch of MutationRecords into semantic add/remove/change events.\n   */\n  _process(mutations) {\n    if (this._disconnected) return;\n\n    const { removed, added, attrChanges } = this._collectFromMutations(mutations);\n    const { reallyAdded, reallyRemoved, swapChanges } = this._diff(removed, added);\n\n    const allChanges = attrChanges.length > 0 || swapChanges.length > 0\n      ? [...attrChanges, ...swapChanges]\n      : [];\n\n    if (reallyAdded.length > 0) this._emit('add', reallyAdded);\n    if (reallyRemoved.length > 0) this._emit('remove', reallyRemoved);\n    if (allChanges.length > 0) this._emit('change', allChanges);\n  }\n\n  /**\n   * Extract keyed nodes and attribute changes from raw MutationRecords.\n   */\n  _collectFromMutations(mutations) {\n    const removed = [];\n    const added = [];\n    const attrChanges = [];\n\n    for (const mutation of mutations) {\n      if (mutation.type === 'childList') {\n        if (mutation.removedNodes.length > 0) {\n          removed.push(...this._collectKeyedFromNodeList(mutation.removedNodes));\n        }\n        if (mutation.addedNodes.length > 0) {\n          added.push(...this._collectKeyedFromNodeList(mutation.addedNodes));\n        }\n      } else if (mutation.type === 'attributes') {\n        const target = mutation.target;\n        if (!target.hasAttribute(this._key)) continue;\n        attrChanges.push({\n          node: target,\n          key: target.getAttribute(this._key),\n          attribute: mutation.attributeName,\n          from: mutation.oldValue,\n          to: target.getAttribute(mutation.attributeName),\n        });\n      }\n    }\n\n    return { removed, added, attrChanges };\n  }\n\n  /**\n   * Diff added/removed nodes by key to distinguish real adds/removes\n   * from innerHTML swap shuffles where the same key exists in both sets.\n   */\n  _diff(removed, added) {\n    const removedMap = new Map();\n    for (const node of removed) {\n      const key = node.getAttribute(this._key);\n      removedMap.set(key, node);\n    }\n\n    const addedMap = new Map();\n    for (const node of added) {\n      const key = node.getAttribute(this._key);\n      addedMap.set(key, node);\n    }\n\n    // Keys present in both maps = same item swapped (innerHTML replace)\n    const matchedKeys = new Set();\n    const swapChanges = [];\n\n    for (const [key, newNode] of addedMap) {\n      const oldNode = removedMap.get(key);\n      if (!oldNode) continue;\n\n      matchedKeys.add(key);\n\n      // Compare watched attributes between old and new node\n      for (const attr of this._watch) {\n        const oldVal = oldNode.getAttribute(attr);\n        const newVal = newNode.getAttribute(attr);\n        if (oldVal !== newVal) {\n          swapChanges.push({\n            node: newNode,\n            key,\n            attribute: attr,\n            from: oldVal,\n            to: newVal,\n          });\n        }\n      }\n    }\n\n    const reallyAdded = [];\n    for (const [key, node] of addedMap) {\n      if (!matchedKeys.has(key)) {\n        reallyAdded.push({ node, key });\n      }\n    }\n\n    const reallyRemoved = [];\n    for (const [key, node] of removedMap) {\n      if (!matchedKeys.has(key)) {\n        reallyRemoved.push({ node, key });\n      }\n    }\n\n    return { reallyAdded, reallyRemoved, swapChanges };\n  }\n\n  /**\n   * Emit an event to all listeners, with error isolation.\n   */\n  _emit(event, entries) {\n    for (const handler of this._listeners[event]) {\n      try {\n        handler(entries);\n      } catch (err) {\n        console.error('HyperChange: error in \"' + event + '\" handler:', err);\n      }\n    }\n  }\n}\n","/**\n * Geometry — create, update, remove Leaflet objects from data attributes.\n *\n * Merged from old Geometry/geometry.js + Geometry/events.js.\n * No global Config dependency — receives options/eventTarget from hyperleaflet.js.\n */\n\nimport * as L from 'leaflet';\n\n// --- Coordinate parsing ---\n\nfunction parseGeometry(raw) {\n  if (typeof raw === 'string') {\n    try {\n      return JSON.parse(raw);\n    } catch {\n      console.warn('hyperleaflet: failed to parse geometry string:', raw);\n      return null;\n    }\n  }\n  return null;\n}\n\n// --- Geometry type registry ---\n\nconst GEOMETRY_TYPES = {\n  point: {\n    create: (coords, style) => L.marker(coords, style),\n    update: (obj, coords) => obj.setLatLng(coords),\n    convert: (coords, lonLat) => (lonLat ? [...coords].reverse() : coords),\n    eventShape: 'mono',\n  },\n  linestring: {\n    create: (coords, style) => L.polyline(coords, style),\n    update: (obj, coords) => obj.setLatLngs(coords),\n    convert: (coords, lonLat) => (lonLat ? L.GeoJSON.coordsToLatLngs(coords, 0) : coords),\n    eventShape: 'poly',\n  },\n  polygon: {\n    create: (coords, style) => L.polygon(coords, style),\n    update: (obj, coords) => obj.setLatLngs(coords),\n    convert: (coords, lonLat) => (lonLat ? L.GeoJSON.coordsToLatLngs(coords, 1) : coords),\n    eventShape: 'poly',\n  },\n  circlemarker: {\n    create: (coords, style) => L.circleMarker(coords, style),\n    update: (obj, coords) => obj.setLatLng(coords),\n    convert: (coords, lonLat) => (lonLat ? [...coords].reverse() : coords),\n    eventShape: 'mono',\n  },\n};\n\n/**\n * Register a custom geometry type.\n * @param {string} type — lowercase type name\n * @param {{ create, update, convert }} handlers\n */\nexport function addGeometryType(type, handlers) {\n  if (!handlers.create || !handlers.update || !handlers.convert) {\n    throw new Error('Invalid handlers provided.');\n  }\n  GEOMETRY_TYPES[type] = handlers;\n}\n\n// --- Inline style extraction from data-* attributes ---\n\n// Leaflet Path options that can be set via data attributes.\n// data-color=\"red\" → { color: 'red' }, data-weight=\"3\" → { weight: 3 }\nconst NUMERIC_STYLE_KEYS = new Set(['weight', 'opacity', 'fillOpacity', 'radius', 'dashOffset']);\nconst STRING_STYLE_KEYS = new Set(['color', 'fillColor', 'dashArray', 'lineCap', 'lineJoin', 'className']);\nconst BOOLEAN_STYLE_KEYS = new Set(['fill', 'stroke']);\n\n/**\n * Extract Leaflet Path style options from a dataset.\n * Returns undefined if no style attributes are found (avoids empty object allocation).\n */\nfunction extractInlineStyle(dataset) {\n  let style;\n\n  for (const key of NUMERIC_STYLE_KEYS) {\n    if (dataset[key] !== undefined) {\n      style = style || {};\n      style[key] = parseFloat(dataset[key]);\n    }\n  }\n  for (const key of STRING_STYLE_KEYS) {\n    if (dataset[key] !== undefined) {\n      style = style || {};\n      style[key] = dataset[key];\n    }\n  }\n  for (const key of BOOLEAN_STYLE_KEYS) {\n    if (dataset[key] !== undefined) {\n      style = style || {};\n      style[key] = dataset[key] !== 'false';\n    }\n  }\n\n  return style;\n}\n\n// --- Internal helpers ---\n\nfunction shouldReverse(globalReverse, elementReverse) {\n  return globalReverse || elementReverse !== undefined;\n}\n\nfunction bindPopupAndTooltip(leafletObj, popup, tooltip) {\n  if (popup) leafletObj.bindPopup(popup);\n  if (tooltip) leafletObj.bindTooltip(tooltip);\n}\n\nfunction attachClickEvent(leafletObj, id, shape, eventTarget, eventsEnabled) {\n  if (!eventsEnabled) return;\n\n  if (shape === 'mono') {\n    leafletObj.on('click', (e) => {\n      eventTarget.dispatchEvent(\n        new CustomEvent('geometry:click', {\n          detail: { clickedPoint: e.latlng, geometry: leafletObj.getLatLng(), id },\n        }),\n      );\n    });\n  } else if (shape === 'poly') {\n    leafletObj.on('click', (e) => {\n      eventTarget.dispatchEvent(\n        new CustomEvent('geometry:click', {\n          detail: { clickedPoint: e.latlng, geometry: leafletObj.getLatLngs(), id },\n        }),\n      );\n    });\n  }\n}\n\n// --- Public API ---\n\n/**\n * Create a Leaflet geometry object from a DOM element's dataset.\n *\n * @param {DOMStringMap} dataset — the element's dataset\n * @param {object} opts\n * @param {boolean} opts.reverseCoordinateOrder — global lon/lat flag\n * @param {object} opts.styles — style lookup { geometryType: { styleName: styleObj } }\n * @param {EventTarget} opts.eventTarget — where to dispatch geometry:click\n * @param {boolean} opts.geometryClickEnabled — whether geometry:click is on\n * @returns {L.Layer}\n */\nexport function createGeometry(dataset, opts) {\n  const { geometry: rawGeometry, geometryType, style, popup, tooltip, id, reverseOrder } = dataset;\n  const coords = parseGeometry(rawGeometry);\n  const typeLower = geometryType.toLowerCase();\n  const typeInfo = GEOMETRY_TYPES[typeLower];\n\n  if (!typeInfo) {\n    throw new Error(`Invalid geometry type: ${geometryType}`);\n  }\n\n  const lonLat = shouldReverse(opts.reverseCoordinateOrder, reverseOrder);\n  const converted = typeInfo.convert(coords, lonLat);\n\n  // Style resolution: config preset as base, inline data-* attributes override\n  const presetStyle = opts.styles?.[typeLower]?.[style];\n  const inlineStyle = extractInlineStyle(dataset);\n  const mergedStyle = presetStyle || inlineStyle\n    ? { ...presetStyle, ...inlineStyle }\n    : undefined;\n\n  const leafletObj = typeInfo.create(converted, mergedStyle);\n  bindPopupAndTooltip(leafletObj, popup, tooltip);\n  attachClickEvent(leafletObj, id, typeInfo.eventShape, opts.eventTarget, opts.geometryClickEnabled);\n\n  return leafletObj;\n}\n\n/**\n * Update an existing Leaflet geometry's position/shape.\n *\n * @param {L.Layer} leafletObj — existing Leaflet layer\n * @param {DOMStringMap} dataset — the element's updated dataset\n * @param {object} opts\n * @param {boolean} opts.reverseCoordinateOrder — global lon/lat flag\n */\nexport function updateGeometry(leafletObj, dataset, opts) {\n  const { geometry: rawGeometry, geometryType, reverseOrder } = dataset;\n  const coords = parseGeometry(rawGeometry);\n  const typeLower = geometryType.toLowerCase();\n  const typeInfo = GEOMETRY_TYPES[typeLower];\n\n  if (!typeInfo) {\n    throw new Error(`Invalid geometry type: ${geometryType}`);\n  }\n\n  const lonLat = shouldReverse(opts.reverseCoordinateOrder, reverseOrder);\n  const converted = typeInfo.convert(coords, lonLat);\n  return typeInfo.update(leafletObj, converted);\n}\n","/**\n * Hyperleaflet — main module.\n *\n * Merges: Map creation, tile layers, layer groups, map events,\n * geometry handler, config, and HyperChange wiring.\n *\n * No extension hooks. No custom EventTarget polyfill.\n * No deep-merge utility. No separate config module.\n */\n\nimport * as L from 'leaflet';\nimport { HyperChange } from './hyperchange';\nimport { createGeometry, updateGeometry, addGeometryType } from './geometry';\n\n// --- Default options ---\n\nconst DEFAULT_OPTIONS = {\n  reverseCoordinateOrder: false,\n  mapElement: '#map',\n  events: {\n    target: 'window',\n    map: {\n      click: true,\n      dblclick: false,\n      mousedown: false,\n      mouseover: false,\n      mousemove: false,\n      mouseout: false,\n      contextmenu: false,\n      preclick: false,\n      zoom: true,\n      move: true,\n      zoomstart: false,\n      zoomend: false,\n      movestart: false,\n      moveend: false,\n      ready: true,\n    },\n    geometry: {\n      click: true,\n      move: false,\n      add: false,\n    },\n    hyperleaflet: {\n      ready: true,\n    },\n  },\n  styles: {},\n};\n\nfunction mergeDeep(target, source) {\n  const out = { ...target };\n  for (const key of Object.keys(source)) {\n    if (\n      source[key] &&\n      typeof source[key] === 'object' &&\n      !Array.isArray(source[key]) &&\n      target[key] &&\n      typeof target[key] === 'object' &&\n      !Array.isArray(target[key])\n    ) {\n      out[key] = mergeDeep(target[key], source[key]);\n    } else {\n      out[key] = source[key];\n    }\n  }\n  return out;\n}\n\n// --- Config (inline, no separate module) ---\n\nconst config = {\n  _hyperleaflet: null,\n  _options: { ...DEFAULT_OPTIONS, events: JSON.parse(JSON.stringify(DEFAULT_OPTIONS.events)) },\n\n  get options() {\n    return this._options;\n  },\n\n  set options(opts) {\n    this._options = mergeDeep(this._options, opts);\n  },\n\n  reset() {\n    this._options = { ...DEFAULT_OPTIONS, events: JSON.parse(JSON.stringify(DEFAULT_OPTIONS.events)) };\n  },\n\n  getTarget() {\n    const { target } = this._options.events;\n    switch (target) {\n      case 'window':\n        return window;\n      case 'document':\n        return document;\n      case 'hyperleaflet':\n      default:\n        return this._hyperleaflet;\n    }\n  },\n};\n\n// --- Built-in tile layers ---\n\nconst BUILT_IN_TILES = {\n  OpenStreetMap: L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {\n    attribution: '&copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>',\n  }),\n  EsriWorldImagery: L.tileLayer(\n    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\n    {\n      attribution:\n        'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',\n    },\n  ),\n};\n\nfunction registerTileLayer(name, { url, minZoom = 0, maxZoom = 18, tms } = {}) {\n  if (BUILT_IN_TILES[name]) return;\n  BUILT_IN_TILES[name] = new L.TileLayer(url, { minZoom, maxZoom, tms: !!tms });\n}\n\nfunction parseTileElements(tileNodeList) {\n  const tileList = Array.from(tileNodeList);\n  const tiles = [];\n\n  for (const el of tileList) {\n    const name = el.dataset.tile;\n    if (!(name in BUILT_IN_TILES)) {\n      const { tileUrl, tms, minZoom, maxZoom } = el.dataset;\n      registerTileLayer(name, { url: tileUrl, tms, minZoom, maxZoom });\n    }\n    tiles.push({ name, tile: BUILT_IN_TILES[name] });\n  }\n\n  // Find default tile\n  const defaultEl = tileList.find((t) => 'defaultTile' in t.dataset);\n  let defaultTile;\n  if (defaultEl && defaultEl.dataset.tile in BUILT_IN_TILES) {\n    defaultTile = BUILT_IN_TILES[defaultEl.dataset.tile];\n  } else if (tileList.length && tileList[0].dataset.tile in BUILT_IN_TILES) {\n    defaultTile = BUILT_IN_TILES[tileList[0].dataset.tile];\n  } else {\n    defaultTile = BUILT_IN_TILES.OpenStreetMap;\n  }\n\n  return { defaultTile, tiles };\n}\n\n// --- Layer groups ---\n\nconst layerGroups = {};\n\nfunction getLayerGroup(name) {\n  return layerGroups[name];\n}\n\nfunction createLayerGroup(name, layerControl) {\n  const group = L.layerGroup();\n  layerGroups[name] = group;\n  layerControl.addOverlay(group, name);\n  return group;\n}\n\nfunction deleteLayerGroupIfEmpty(name, layerControl) {\n  if (!name || !layerGroups[name]) return;\n  if (layerGroups[name].getLayers().length) return;\n  const group = layerGroups[name];\n  delete layerGroups[name];\n  layerControl.removeLayer(group);\n}\n\n// --- Map creation ---\n\nfunction safeParsePoint(raw, reverse) {\n  try {\n    const point = JSON.parse(raw);\n    return reverse ? point.reverse() : point;\n  } catch {\n    return [0, 0];\n  }\n}\n\nfunction createMap(container) {\n  const { mapConfig } = container.dataset;\n  const target = mapConfig ? document.querySelector(mapConfig) : container;\n  if (!target) throw new Error('hyperleaflet: no map config found');\n\n  const { center, zoom, minZoom, maxZoom } = target.dataset;\n  const reverse = config.options.reverseCoordinateOrder;\n\n  const leafletMap = L.map(container, {\n    center: safeParsePoint(center, reverse),\n    zoom: zoom || 1,\n    minZoom: minZoom || 0,\n    maxZoom: maxZoom || 18,\n  });\n\n  return [leafletMap, target];\n}\n\n// --- Map events ---\n\nconst STATE_EVENTS = ['zoomstart', 'zoomend', 'movestart', 'moveend', 'zoom', 'move'];\nconst MOUSE_EVENTS = ['click', 'dblclick', 'mousedown', 'mouseover', 'mouseout', 'mousemove', 'contextmenu', 'preclick'];\n\nfunction createStateEvent(map, name, leafletEvent) {\n  const bounds = map.getBounds();\n  return new CustomEvent(name, {\n    detail: {\n      zoom: map.getZoom(),\n      center: map.getCenter(),\n      bbox: { min: bounds.getSouthWest(), max: bounds.getNorthEast() },\n      bboxString: bounds.toBBoxString(),\n      _leafletEvent: leafletEvent,\n    },\n  });\n}\n\nfunction bindMapEvents(map, eventTarget) {\n  const mapEvents = config.options.events.map;\n\n  for (const [name, enabled] of Object.entries(mapEvents)) {\n    if (!enabled) continue;\n\n    if (STATE_EVENTS.includes(name)) {\n      map.on(name, (e) => eventTarget.dispatchEvent(createStateEvent(map, `map:${name}`, e)));\n    }\n    if (MOUSE_EVENTS.includes(name)) {\n      map.on(name, (e) => {\n        eventTarget.dispatchEvent(\n          new CustomEvent(`map:${name}`, { detail: { point: e.latlng, _leafletEvent: e } }),\n        );\n      });\n    }\n  }\n\n  if (mapEvents.ready) {\n    map.whenReady(() => eventTarget.dispatchEvent(createStateEvent(map, 'map:ready')));\n  }\n}\n\nfunction sendHyperleafletReady(map, eventTarget) {\n  if (!config.options.events.hyperleaflet.ready) return;\n  const bounds = map.getBounds();\n  eventTarget.dispatchEvent(\n    new CustomEvent('hyperleaflet:ready', {\n      detail: {\n        zoom: map.getZoom(),\n        center: map.getCenter(),\n        bbox: { min: bounds.getSouthWest(), max: bounds.getNorthEast() },\n        bboxString: bounds.toBBoxString(),\n      },\n    }),\n  );\n}\n\n// --- Geometry handler (fixed: uses HyperChange API correctly) ---\n\n// O(1) lookup by data-id instead of O(n) layer scan\nconst geometryIndex = new Map();\n\nfunction addNode(node, map, layerControl) {\n  const { dataset } = node;\n  const { layerName, id } = dataset;\n\n  let target = map;\n  if (layerName) {\n    const existing = getLayerGroup(layerName);\n    if (existing) {\n      target = existing;\n    } else {\n      target = createLayerGroup(layerName, layerControl);\n      target.addTo(map);\n    }\n  }\n\n  const opts = {\n    reverseCoordinateOrder: config.options.reverseCoordinateOrder,\n    styles: config.options.styles,\n    eventTarget: config.getTarget(),\n    geometryClickEnabled: config.options.events.geometry.click,\n  };\n\n  const leafletObj = createGeometry(dataset, opts);\n  leafletObj.hlID = id;\n  leafletObj.addTo(target);\n  geometryIndex.set(id, { layer: leafletObj, target });\n}\n\nfunction removeNode(node, layerControl) {\n  const id = node.dataset.id;\n  const entry = geometryIndex.get(id);\n  if (!entry) return;\n\n  entry.target.removeLayer(entry.layer);\n  geometryIndex.delete(id);\n\n  const layerName = node.dataset.layerName;\n  deleteLayerGroupIfEmpty(layerName, layerControl);\n}\n\n/**\n * Handle attribute change from HyperChange.\n * HyperChange emits: { node, key, attribute, from, to }\n * Old code incorrectly accessed change['data-id'] and change.dataset — FIXED.\n */\nfunction changeNode(change) {\n  const id = change.key;\n  const entry = geometryIndex.get(id);\n  if (!entry) return;\n\n  if (change.attribute === 'data-geometry') {\n    const opts = {\n      reverseCoordinateOrder: config.options.reverseCoordinateOrder,\n    };\n    updateGeometry(entry.layer, change.node.dataset, opts);\n  }\n  // Other attribute changes could be handled here in the future\n}\n\n// --- Hyperleaflet object ---\n\nconst HYPERLEAFLET_DATA_SOURCE = '[data-hyperleaflet-source]';\n\nexport const Hyperleaflet = {\n  map: null,\n  target: null,\n  _hyperchange: null,\n  _layerControl: null,\n\n  initialize(mapContainer) {\n    if (!mapContainer) {\n      console.warn('hyperleaflet: no map container found.');\n      return;\n    }\n    mapContainer.setAttribute('hyperleaflet', '');\n\n    const eventTarget = config.getTarget();\n    const [map, target] = createMap(mapContainer);\n    this.map = map;\n    this.target = target;\n\n    // Tile layers + layer control\n    this._layerControl = L.control.layers();\n    this._layerControl.addTo(map);\n\n    const tileElements = mapContainer.querySelectorAll('[data-tile]');\n    const { defaultTile, tiles } = parseTileElements(tileElements);\n\n    for (const { name, tile } of tiles) {\n      this._layerControl.addBaseLayer(tile, name);\n    }\n    defaultTile.addTo(map);\n\n    // Map events\n    bindMapEvents(map, eventTarget);\n\n    // Wire up data source\n    this._initDataSource(eventTarget);\n\n    // Ready event\n    sendHyperleafletReady(map, eventTarget);\n  },\n\n  _initDataSource(eventTarget) {\n    const source = document.querySelector(HYPERLEAFLET_DATA_SOURCE);\n    if (!source) return;\n\n    const layerControl = this._layerControl;\n    const map = this.map;\n\n    this._hyperchange = new HyperChange(source, {\n      key: 'data-id',\n      watch: ['data-geometry'],\n    });\n\n    this._hyperchange.on('add', (entries) => {\n      for (const entry of entries) {\n        addNode(entry.node, map, layerControl);\n      }\n    });\n\n    this._hyperchange.on('remove', (entries) => {\n      for (const entry of entries) {\n        removeNode(entry.node, layerControl);\n      }\n    });\n\n    this._hyperchange.on('change', (entries) => {\n      for (const entry of entries) {\n        changeNode(entry);\n      }\n    });\n\n    // Process initial elements already in the DOM\n    map.whenReady(() => {\n      this._hyperchange.scan();\n    });\n  },\n\n  // --- Public API ---\n\n  getZoom() {\n    return this.map.getZoom();\n  },\n  setZoom(zoom) {\n    this.map.setZoom(zoom);\n  },\n  getCenter() {\n    return this.map.getCenter();\n  },\n  getBounds() {\n    return this.map.getBounds();\n  },\n  getBBoxString() {\n    return this.map.getBounds().toBBoxString();\n  },\n  panTo(center) {\n    this.map.panTo(center);\n  },\n  flyTo(center, zoom) {\n    this.map.flyTo(center, zoom || this.map.getZoom());\n  },\n  flyToBounds(bounds) {\n    this.map.flyToBounds(bounds);\n  },\n  fitBounds(bounds) {\n    this.map.fitBounds(bounds);\n  },\n\n  getLayer(id) {\n    const entry = geometryIndex.get(id);\n    return entry ? entry.layer : null;\n  },\n\n  openPopup(id) {\n    const entry = geometryIndex.get(id);\n    if (entry && entry.layer.openPopup) entry.layer.openPopup();\n  },\n\n  closePopup(id) {\n    const entry = geometryIndex.get(id);\n    if (entry && entry.layer.closePopup) entry.layer.closePopup();\n  },\n\n  addGeometryType(type, handlers) {\n    addGeometryType(type, handlers);\n  },\n};\n\n// Expose config on Hyperleaflet\nHyperleaflet.config = config;\nconfig._hyperleaflet = Hyperleaflet;\n\n// Make Hyperleaflet act as an EventTarget for addEventListener/removeEventListener/dispatchEvent\nconst _eventListeners = {};\n\nHyperleaflet.addEventListener = function (type, listener) {\n  if (!(type in _eventListeners)) _eventListeners[type] = [];\n  _eventListeners[type].push(listener);\n};\n\nHyperleaflet.removeEventListener = function (type, listener) {\n  if (!(type in _eventListeners)) return;\n  const idx = _eventListeners[type].indexOf(listener);\n  if (idx !== -1) _eventListeners[type].splice(idx, 1);\n};\n\nHyperleaflet.dispatchEvent = function (event) {\n  if (!(event.type in _eventListeners)) return true;\n  for (const listener of _eventListeners[event.type].slice()) {\n    listener.call(Hyperleaflet, event);\n  }\n  return !event.defaultPrevented;\n};\n","/**\n * Hyperleaflet entry point.\n *\n * Auto-initializes on DOMContentLoaded. If #map isn't in the DOM yet\n * (SPA routing), watches for it with a body MutationObserver.\n */\n\nimport { Hyperleaflet } from './hyperleaflet';\n\nfunction initializeMap() {\n  const container = document.querySelector(Hyperleaflet.config.options.mapElement);\n  if (container) {\n    Hyperleaflet.initialize(container);\n    return true;\n  }\n  return false;\n}\n\nfunction observeMap() {\n  const observer = new MutationObserver((_mutations, obs) => {\n    if (initializeMap()) {\n      obs.disconnect();\n    }\n  });\n  observer.observe(document.body, { childList: true, subtree: true });\n}\n\n(function () {\n  document.addEventListener('DOMContentLoaded', () => {\n    if (!initializeMap()) {\n      observeMap();\n    }\n  });\n})();\n\nwindow.hyperleaflet = Hyperleaflet;\nexport { Hyperleaflet as hyperleaflet };\n"],"names":["VALID_EVENTS","HyperChange","root","options","_this","this","HTMLElement","Error","key","_root","_key","_watch","watch","_batch","batch","_listeners","add","remove","change","_frameId","_pendingMutations","_disconnected","hasWatch","length","_observer","MutationObserver","mutations","_this$_pendingMutatio","push","apply","requestAnimationFrame","splice","_process","observe","childList","subtree","attributes","attributeFilter","undefined","attributeOldValue","_proto","prototype","on","event","handler","_this2","includes","join","filter","h","off","scan","_this3","nodes","_collectKeyedNodes","_emit","map","node","getAttribute","disconnect","cancelAnimationFrame","result","stack","i","childNodes","pop","nodeType","hasAttribute","_collectKeyedFromNodeList","nodeList","_step","_iterator","_createForOfIteratorHelperLoose","done","value","child","_this$_collectFromMut","_collectFromMutations","attrChanges","_this$_diff","_diff","removed","added","reallyAdded","reallyRemoved","swapChanges","allChanges","concat","_step2","_iterator2","mutation","type","removedNodes","addedNodes","target","attribute","attributeName","from","oldValue","to","_step3","removedMap","Map","_iterator3","set","_step4","addedMap","_iterator4","_step5","matchedKeys","Set","_iterator5","_step5$value","newNode","oldNode","get","_step8","_iterator8","attr","oldVal","newVal","_step6","_iterator6","_step6$value","has","_step7","_iterator7","_step7$value","entries","_step9","_iterator9","err","console","error","parseGeometry","raw","JSON","parse","_unused","warn","GEOMETRY_TYPES","point","create","coords","style","L","marker","update","obj","setLatLng","convert","lonLat","reverse","eventShape","linestring","polyline","setLatLngs","GeoJSON","coordsToLatLngs","polygon","circlemarker","circleMarker","NUMERIC_STYLE_KEYS","STRING_STYLE_KEYS","BOOLEAN_STYLE_KEYS","shouldReverse","globalReverse","elementReverse","DEFAULT_OPTIONS","reverseCoordinateOrder","mapElement","events","click","dblclick","mousedown","mouseover","mousemove","mouseout","contextmenu","preclick","zoom","move","zoomstart","zoomend","movestart","moveend","ready","geometry","hyperleaflet","styles","mergeDeep","source","out","_extends","_i","_Object$keys","Object","keys","Array","isArray","config","_hyperleaflet","_options","stringify","opts","reset","getTarget","window","document","BUILT_IN_TILES","OpenStreetMap","tileLayer","attribution","EsriWorldImagery","registerTileLayer","name","_temp","_ref","_ref$minZoom","minZoom","_ref$maxZoom","maxZoom","TileLayer","url","tms","layerGroups","safeParsePoint","STATE_EVENTS","MOUSE_EVENTS","createStateEvent","leafletEvent","bounds","getBounds","CustomEvent","detail","getZoom","center","getCenter","bbox","min","getSouthWest","max","getNorthEast","bboxString","toBBoxString","_leafletEvent","geometryIndex","addNode","layerControl","dataset","layerName","id","existing","group","layerGroup","addOverlay","createLayerGroup","addTo","leafletObj","_opts$styles","geometryType","popup","tooltip","reverseOrder","typeLower","toLowerCase","typeInfo","converted","presetStyle","inlineStyle","parseFloat","extractInlineStyle","mergedStyle","bindPopup","bindTooltip","bindPopupAndTooltip","shape","eventTarget","eventsEnabled","e","dispatchEvent","clickedPoint","latlng","getLatLng","getLatLngs","attachClickEvent","geometryClickEnabled","createGeometry","hlID","layer","removeNode","entry","removeLayer","getLayers","deleteLayerGroupIfEmpty","Hyperleaflet","_hyperchange","_layerControl","initialize","mapContainer","setAttribute","_createMap","container","mapConfig","querySelector","_target$dataset","createMap","control","layers","_parseTileElements","tileNodeList","tileList","tiles","_i2","_tileList","el","tile","_el$dataset","tileUrl","defaultEl","find","t","defaultTile","parseTileElements","querySelectorAll","_step$value","addBaseLayer","mapEvents","_loop","_Object$entries$_i","_Object$entries","_i3","enabled","whenReady","bindMapEvents","_initDataSource","sendHyperleafletReady","updateGeometry","setZoom","getBBoxString","panTo","flyTo","flyToBounds","fitBounds","getLayer","openPopup","closePopup","addGeometryType","handlers","_eventListeners","initializeMap","addEventListener","listener","removeEventListener","idx","indexOf","slice","call","defaultPrevented","_mutations","obs","body"],"mappings":"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"}